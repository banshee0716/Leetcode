class Solution:
    def paintWalls(self, cost: List[int], time: List[int]) -> int:
        n = len(cost)  # 總牆數
        dp = [float('inf')] * (n+1)  # 初始化 dp 陣列
        dp[0] = 0  # 0面牆的成本是0
        
        # 遍歷每面牆，計算當前牆與之前牆的最小成本
        for i in range(n):
            for j in range(n, 0, -1):
                # 使用 max 確保不會有負的索引出現
                dp[j] = min(dp[j], dp[max(j - time[i] - 1, 0)] + cost[i])
                
        return dp[n]  # 返回畫完所有牆的最小成本
"""
如何最優化地使用兩位畫家（其中一位需要支付費用，但畫得快；另一位是免費的，但每次只能花費1個時間單位）來畫牆，以確保總成本最小。

解題思路：
1. 使用動態規劃（Dynamic Programming）的方式來解這題。
2. 定義 dp[i] 為畫完前 i 面牆的最小成本。初值為無窮大，表示不可能的情況。
3. 遍歷每面牆，更新 dp[i] 的值，使其為免費畫家和付費畫家兩者之間的最小值。付費畫家需要考慮前面已經畫好的牆的數量與其所需時間。

時間複雜度：
由於我們遍歷了每一面牆，然後再次遍歷已經處理的牆來計算成本，所以時間複雜度為 O(n^2)，其中 n 是牆的數量。

空間複雜度：
我們使用了一個長度為n+1 的 dp 陣列，所以空間複雜度為 O(n)。
"""