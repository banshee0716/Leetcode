class Solution:
    def tallestBillboard(self, rods: List[int]) -> int:
        # 初始化動態規劃字典，當兩邊的高度差為 0 時，較矮的那邊的高度為 0
        dp = {0: 0}

        # 遍歷每個桿子
        for x in rods:
            # 複製當前的 dp 字典
            cur = dp.copy()

            # 遍歷當前的 dp 字典
            for d, y in cur.items():
                # 把桿子加在更高的那邊，並更新 dp[d + x] 的值
                dp[d + x] = max(dp.get(d + x, 0), y)

                # 把桿子加在更矮的那邊，並更新 dp[abs(d - x)] 的值
                dp[abs(d - x)] = max(dp.get(abs(d - x), 0), y + min(d, x))

        # 返回兩邊高度相等時，較矮的那邊的高度
        return dp[0]

    
"""
您正在安裝廣告牌並希望其具有最大的高度。廣告牌將有兩個鋼支架，每一側一個。每個鋼支撐必須具有相同的高度。
您將獲得一組可以焊接在一起的桿。例如，如果您有長度為 1、2 和 3 的桿，則可以將它們焊接在一起以形成長度為 6 的支架。
返回廣告牌安裝的最大可能高度。如果您不能支持廣告牌，請返回 0。
"""

"""
使用動態規劃。我們維護一個字典 dp，其中 dp[d] 代表當兩邊的高度差為 d 時，較矮的那邊的最大高度。
我們依次遍歷每個桿子，並更新 dp 字典。
對於每個桿子，我們有兩種選擇：把它加在更高的那邊，或者把它加在更矮的那邊。因此，我們需要更新 dp[d + x] 和 dp[abs(d - x)] 的值。

時間複雜度
為 O(n^2)，其中 n 為桿子的數量。因為我們需要遍歷每個桿子，並且對於每個桿子，我們需要遍歷當前的 dp 字典。

空間複雜度
為 O(n)，因為我們需要儲存 dp 字典。
"""