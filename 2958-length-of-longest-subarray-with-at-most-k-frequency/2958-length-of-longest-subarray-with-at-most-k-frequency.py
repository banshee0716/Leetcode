class Solution:
    def maxSubarrayLength(self, nums: List[int], k: int) -> int:
        ans = 0
        mp = {}
        l = 0
        n = len(nums)
        
        for r in range(n):
            mp[nums[r]] = mp.get(nums[r], 0) + 1
            if mp[nums[r]] > k:
                while nums[l] != nums[r]:
                    mp[nums[l]] -= 1
                    l += 1
                    
                mp[nums[l]] -= 1
                l += 1
            
            ans = max(r-l+1, ans)
            
        return ans
                
                
        
        
        
        
        """
給定一個整數數組 nums 和一個整數 k。元素 x 的頻率是它在陣列中出現的次數。

如果數組中每個元素的頻率小於或等於 k，則該數組稱為良好數組。

傳回 nums 的最長有效子數組的長度。子數組是數組中連續的非空元素序列。

解題思路
這個問題可以透過雙指針和哈希表來解決，具體步驟如下：

1. 初始化：定義一個哈希表mp來記錄子數組中元素的出現次數，l和r分別作為子數組的左右指針，ans記錄目前為止找到的最長好子數組的長度。
2. 遍歷數組：以右指針r遍歷數組nums。
3.更新哈希表：每當右指針移動到新元素時，更新該元素在哈希表中的頻率。
4. 檢查並調整子數組：如果當前元素的頻率超過k，則需要移動左指針l，直到該元素的頻率不超過k。
5.更新答案：在每次迭代中，如果當前子數組是好數組，則嘗試更新最長好子數組的長度ans。

時間複雜度分析
遍歷整個數組的時間複雜度為O(N)，其中N是數組nums的長度。
在最壞情況下，左指針l和右指針r各自最多遍歷整個數組一次，因此總的時間複雜度仍然為O(N)。

空間複雜度分析
使用了一個哈希表來記錄子數組中元素的頻率，哈希表的大小取決於子數組中不同元素的數量，最壞情況下的空間複雜度為O(N)。
        """