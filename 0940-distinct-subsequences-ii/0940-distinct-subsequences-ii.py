class Solution:
    def distinctSubseqII(self, s: str) -> int:
        # end[i] 表示結尾字元為第i個字母的子序列數量
        # 初始化為0
        end = [0] * 26
        
        # 遍歷輸入字串的每個字元
        for c in s:
            # 更新結尾為當前字元的子序列數量
            # 該數量為所有其他子序列數量的總和加1（代表當前字元本身獨立成為一個子序列）
            end[ord(c) - ord('a')] = sum(end) + 1
        
        # 返回所有子序列的總和
        return sum(end) % (10**9 + 7)

"""
https://www.jianshu.com/p/02501f516437

解釋
初始化一個數組以[26]結尾
endswith[i] 統計有多少個以第 i 個字符結尾的子序列。

現在我們有 N = sum(endswith) 不同的子序列，
為每個字符添加一個新字符 c，
那麼我們就有 N 個以 c 結尾的不同子序列。

有了這個想法，我們循環整個字符串 S，
我們為每個字符更新 end[c] = sum(end) + 1。

這裡我們需要加一，因為“c”本身也是一個子序列。


時間複雜度：O(n * 26) = O(n)，其中 n 是輸入字串的長度。因為我們遍歷每個字元，且針對每個字元計算子序列數量時需要遍歷26個可能的結尾字元。
空間複雜度：O(26) = O(1)，我們使用固定大小的 end 陣列來儲存資訊。
"""