首先，這題的關鍵是當前的 s 可能表示一個非常大的解碼後的字串，如果我們真的完整解碼出這個字串，那麼不僅會極大地消耗時間，還會消耗非常多的空間。因此，我們需要找一種方式在不真正解碼整個字串的情況下找到第 k 個字符。

## 為何需要前向迭代？

我們需要知道完整解碼後的字串長度是多少，這對於後面的反向迭代非常重要。如果不知道完整的長度，我們無法確定如何更新 k 以及當前的位置在反向迭代中對應於哪一個解碼後的字符。

## 為何需要反向迭代？

題目要求找到解碼後第 k 個字符。當我們知道完整的解碼長度後，從尾部開始考慮是合理的，因為這樣我們可以有效地模擬字符被解碼並重複的過程。
例如，考慮 s = "a2b3", k = 8。解碼後的字串是 aabbbbaaabbbb，而第8個字符是 a。在反向迭代中，我們會先碰到 3，這表示字串 b 被重複了3次。<br>
當遇到重複的數字時，我們更新 length 並將 k 取餘，這樣我們可以確定 k 在這三個重複之間的哪一個。如果遇到字符，我們就將 length 減少並檢查 k 是否指向該字符。
使用反向迭代的好處是，當我們遇到一個數字，我們可以快速地跳過大量的字符，而不需要真正地解碼整個段落。這就是為什麼這個方法在時間和空間上都很高效。

總之，這個方法的優點是它可以避免真正地解碼整個字串，而是使用數學計算來快速地找到第 k 個字符。這就是為什麼選擇這個解題思路。



