class Solution:
    def minimumOneBitOperations(self, n: int) -> int:
        res = 0
        while n:
            # 累加操作次數
            res = -res - (n ^ (n - 1))
            # 去掉最低位的1
            n &= n - 1
        # 返回操作次數的絕對值
        return abs(res)

# 使用black格式化後的代碼與上述代碼在格式上已經符合標準

        
    """
給定一個整數 n，您必須使用以下操作任意多次將其轉換為 0：

    -更改 n 的二進位表示形式中最右邊（第 0）位元。
    -如果第 (i-1) 位元設定為 1 且第 (i-2) 位元到第 0 位元設為 0，則變更 n 的二進位表示法中的第 i 位元。
傳回將 n 轉換為 0 的最少運算次數。
    
    
利用位操作：
    -這個問題可以通過位操作來解決。具體來說，就是逐位考慮 n，並逐步減少 n。

逐步減少 n：
    -在每次迭代中，使用 n & (n - 1) 可以去掉 n 的最低位的1。這是因為從 n 到 n - 1，最低位的1會變成0，並且所有更低位的位會翻轉。

計算操作次數：
    -使用 n ^ (n - 1) 計算從 n 到 n - 1 所有改變的位，然後使用 -res - ... 來累加操作次數。

返回結果：
    -因為操作次數可能是負數，所以最後返回 abs(res)。
    
時間複雜度分析：
這個算法的時間複雜度與 n 的位數有關。因為每次迭代都會去掉一個1，所以時間複雜度為 O(log n)，其中 log n 是 n 的位數。

空間複雜度分析：
這個算法只使用了固定的額外空間來存儲變數 res 和 n，因此空間複雜度為 O(1)。
    """