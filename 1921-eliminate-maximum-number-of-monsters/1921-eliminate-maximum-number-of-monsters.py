class Solution:
    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
        # 計算每個怪物到達城市的時間
        time_to_city = [dist[i] / speed[i] for i in range(len(dist))]
        # 對到達時間進行排序
        time_to_city.sort()
        # 遍歷每個怪物
        for i in range(len(dist)):
            # 如果怪物到達城市的時間小於或等於消滅怪物的數量，則返回當前消滅的數量
            if time_to_city[i] <= i:
                return i
        # 如果所有怪物都能在到達城市前被消滅，返回怪物的總數
        return len(dist)

# 使用black格式化後的代碼與上述代碼在格式上已經符合標準

        
    """
你正在玩一款電玩遊戲，你要保衛你的城市免受 n 個怪物的攻擊。
給定一個大小為 n 的 0 索引整數數組 dist，其中 dist[i] 是第 i 個怪物距城市的初始距離（以公里為單位）。

怪物們以恆定的速度朝城市走去。每個怪物的速度以大小為 n 的整數數組 speed 的形式給出，其中 speed[i] 是第 i 個怪物的速度（以公里每分鐘為單位）。

你擁有一把武器，一旦充滿電，就可以消滅一個怪物。然而，該武器需要一分鐘才能充電。武器一開始就充滿電。

當任何怪物到達你的城市時你就輸了。如果怪物在武器充滿電的同時到達城市，則視為失敗，遊戲在您可以使用武器之前結束。

返回你輸掉之前可以消滅的怪物的最大數量，如果你能在怪物到達城市之前消滅掉所有怪物，則返回n。

這題的解題思路如下：

1. 首先計算每個怪物到達城市的時間，這可以通過將怪物到城市的距離除以其速度來獲得。
    - 將這些時間按從小到大的順序排序，這樣我們可以先處理那些最先到達城市的怪物。
2. 遍歷這個排序後的時間列表：
    - 如果怪物到達城市的時間小於或等於你消滅怪物的數量（即經過的時間），這意味著你來不及消滅這個怪物，它會到達城市。
    - 如果你能在所有怪物到達之前將它們全部消滅，那麼你能消滅的最大數量就是所有怪物的數量。
    
時間複雜度分析：
- 計算每個怪物到達城市的時間是 O(n)。
- 對這些時間進行排序是 O(n log n)。
- 遍歷排序後的時間列表是 O(n)。

綜上，總的時間複雜度為 O(n log n)，因為排序的時間複雜度是主導因素。

空間複雜度分析：
額外空間用於儲存每個怪物到達城市的時間，空間複雜度為 O(n)。
    
    """
    
    