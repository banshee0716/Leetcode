class Solution:
    def findIntegers(self, num: int) -> int:
        x, y = 1, 2  # 初始化斐波那契的前兩個數
        res = 0
        num += 1
        while num:
            # 如果num的這個位元和下一個位元都是1，則之前的res值不再有效
            if num & 1 and num & 2:
                res = 0

            # 更新res
            res += x * (num & 1)
            
            # 右移num，考慮下一個位元
            num >>= 1
            
            # 更新斐波那契數列的值
            x, y = y, x + y
        
        return res

        
"""
解題思路：

1. 由於我們要尋找小於等於num且在二進制表示中不包含連續的1的數的總數，因此我們可以使用斐波那契數列的概念。因為，例如考慮5位數的二進制數，其結構會有0b0XXXX或0b10XXX，所以有效整數的數量是a(4) + a(3)，這與斐波那契數列的性質一致。

2. 這裡使用x和y來計算斐波那契數列的數值，同時使用num的每個位元來更新答案。

3. 若num的連續兩個位元都是1，則將答案設為0，因為這種情況下的數都不是有效的。

時間複雜度：
O(log(num))：我們需要檢查num的每一個位元。

空間複雜度：
O(1)：只使用了常數的額外空間。
"""