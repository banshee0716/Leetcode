class Solution:
    def knightDialer(self, n: int) -> int:
        MOD = 10 ** 9 + 7
        # 騎士的移動規則
        moves = {
            0: [4, 6], 1: [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9],
            5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]
        }
        # 初始化dp字典
        dp = dict()
        for i in range(10):
            dp[(1, i)] = 1
        
        # 構建動態規劃表
        for m in range(2, n + 1):
            for currDigit in range(10):
                dp[(m, currDigit)] = sum(dp[(m - 1, nextDigit)] for nextDigit in moves[currDigit]) % MOD

        # 計算最終結果
        return sum(dp[(n, i)] for i in range(10)) % MOD
    
    
    


"""
解題思路：
使用動態規劃的方法來解決這個問題。定義 dp[m, i] 為從數字 i 開始，撥打長度為 m 的號碼的組合數量。

初始化基本情況：
    -對於撥打長度為 1 的所有號碼，組合數量均為 1。

構建轉移方程：
    -根據騎士的移動規則，從每個數字可以移動到特定的一組數字上。使用一個字典 moves 來存儲這些移動規則。
    -然後對於撥打長度從 2 到 n 的每一個長度，對於每一個數字，計算從它能到達的每個數字的組合數量之和。

計算結果並返回：
    -最後將長度為 n、起始於所有數字的組合數量加起來，得到最終的結果。

時間複雜度分析：
這個算法的時間複雜度主要來自於兩層嵌套的循環。外層循環遍歷從 2 到 n，內層循環遍歷從 0 到 9。每次內層循環中，計算一個和，其時間複雜度為常數。因此，總的時間複雜度為 O(n)。

空間複雜度分析：
這個算法使用了一個字典來存儲中間結果，字典的大小最多為 10n，所以空間複雜度為 O(n)。


"""
