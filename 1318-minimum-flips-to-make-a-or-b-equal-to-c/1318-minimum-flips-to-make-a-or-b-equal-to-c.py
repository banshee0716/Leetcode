class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        # 將 a 和 b 進行 "或" 運算，結果與 c 進行 "異或" 運算，並將結果賦值給 c
        # 計算結果中的位元 1 的個數（需要翻轉的位數）
        # 再加上 a 和 b 和 c 都為 1 的位數（需要翻轉的位數）
        return (c := (a | b) ^ c).bit_count() + (a & b & c).bit_count()
"""
解題思路:

1. 我們需要計算使得 a OR b = c 需要的最小翻轉數。首先，我們使用位元 "或" 運算符計算 a OR b，然後使用位元 "異或" 運算符計算 (a OR b) XOR c，這將給出需要翻轉的位的位置。

2. 但這還不夠，因為還有一種情況需要處理：如果 a、b、c 在某一位上都是 1，那麼我們需要兩次翻轉（將 a 或 b 中的這一位翻轉為 0，然後將 c 中的這一位翻轉為 0）。

3. 因此，我們需要計算 (a OR b) XOR c 中 1 的數量（這表示需要翻轉的位數），再加上 a AND b AND c 中 1 的數量（這表示需要額外翻轉的位數）。

時間複雜度:
O(1) - 因為輸入是固定長度的整數，所以運算的時間複雜度是常數。
空間複雜度:
O(1) - 這個解法只使用了固定數量的變數，所以空間複雜度也是常數。

"""