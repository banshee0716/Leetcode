class Solution:
    def numberOfWays(self, corridor: str) -> int:
        # 找出所有 'S' 的位置
        places = [i for i, x in enumerate(corridor) if corridor[i] == "S"]
        m = len(places)
        # 檢查 'S' 的數量是否合法
        if m % 2 == 1 or m < 2: return 0
        
        ans = 1
        # 計算方法數
        for i in range(m // 2 - 1):
            ans = (ans * (places[2 * i + 2] - places[2 * i + 1])) % (10**9 + 7)
            
        return ans


        

    """
解題思路：

找出所有 'S' 的位置：
    -遍歷字符串，記錄所有 'S' 字符的索引。

檢查 'S' 的數量：
    -如果 'S' 的總數是奇數，或者少於 2 個，則無法將所有的 'S' 分成兩兩一組，返回 0。

計算方法數：
    -遍歷所有 'S' 的位置，計算相鄰兩對 'S' 之間的 'P' 字符數量。每一對 'S' 之間的 'P' 的數量加 1 就是這一對 'S' 可以有的不同分法數量。
    -將這些數量相乘，得到最終的方法數。由於結果可能很大，所以每次乘法後都取模 10^9 + 7。

時間複雜度分析：
遍歷字符串以找出所有 'S' 的位置的時間複雜度為 O(n)，其中 n 是字符串的長度。
遍歷 'S' 的位置並計算方法數的時間複雜度為 O(m/2)，其中 m 是 'S' 的總數。
總的時間複雜度為 O(n + m/2)，可以近似為 O(n)。

空間複雜度分析：
需要額外的空間來存儲 'S' 的位置，空間複雜度為 O(m)，其中 m 是 'S' 的總數。
"""