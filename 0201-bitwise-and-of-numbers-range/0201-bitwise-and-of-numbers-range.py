class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        i = 0  # 用於記錄右移的位數
        while left != right:
            left >>= 1  # 將left右移
            right >>= 1  # 將right右移
            i += 1  # 累計右移的位數
            
        return right << i  # 將找到的共同前綴左移，恢復到原來的位數

"""
解題思路
這個問題的關鍵在於觀察按位與操作的性質。對於範圍內的連續數字進行按位與操作，只有當這些數字的二進位表示在某些位上全部為1時，結果的該位才為1。隨著範圍的增加，最終結果趨向於0，因為範圍內至少會有一個數字在每個位上為0。

這個問題可以通過不斷將left和right右移，直到它們相等來解決。這樣做的原因是，當left和right不相等時，至少有一個數的最低位會從0變成1（或者反過來），這會使得最終的按位與結果的該位為0。通過右移，我們實際上是在縮小範圍，直到找到left和right的共同前綴，因為這個共同前綴將是最終按位與結果的非零部分。

時間複雜度
這個算法的時間複雜度為O(logn)，其中n為right - left的值。在最壞的情況下，即left和right相差很大時，我們需要進行對數級別的迭代次數來找到它們的共同前綴。

空間複雜度
這個算法只使用了固定的額外空間來存儲幾個變量（如i、更新後的left和right值），因此空間複雜度為O(1)。
"""