from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        res = []  # 初始化結果陣列
        left, right = 0, 0  # 定義滑動窗口的左邊界和右邊界
        q = deque()  # 初始化雙端隊列

        while right < len(nums):  # 當滑動窗口的右邊界沒超過陣列的邊界時
            
            # 移除隊列中比當前元素小的元素的索引
            while q and nums[right] > nums[q[-1]]:
                q.pop()

            q.append(right)  # 將當前元素的索引加入隊列

            # 如果滑動窗口的左邊界超過了隊列的第一個元素的索引，移除隊列的第一個元素
            if left > q[0]:
                q.popleft()
            
            # 只要滑動窗口的大小大於或等於k，將隊列的第一個元素（也就是窗口的最大值）加入結果陣列
            if right + 1 >= k:
                res.append(nums[q[0]])
                left += 1

            right += 1
        
        return res

        
        """
給定一個整數數組 nums，有一個大小為 k 的滑動窗口，它從數組的最左邊移動到最右邊。窗口中只能看到k個數字。每次滑動窗口右移一個位置。

返回最大滑動窗口。

解題思路:

1. 使用一個雙端隊列 q 來保存滑動窗口內的元素。這個隊列中保存的是元素的索引，不是實際的值。
2. 在每一步中，添加元素到滑動窗口和q，並且在加入之前，移除那些比當前元素小的元素。因為我們只關心最大值，所以小的值沒有意義。
3. 如果滑動窗口的左邊超過了隊列的第一個元素的索引，那麼移除隊列的第一個元素。
4. 只要滑動窗口的大小大於或等於k，就將隊列的第一個元素（也就是窗口的最大值）加入結果陣列。

時間複雜度: 
O(n)，其中n是nums的長度。儘管程式碼中有內部循環，但由於每個元素只會被添加和移除隊列一次，所以時間複雜度是線性的。

空間複雜度: 
O(k)，雙端隊列的大小不會超過k。
        """