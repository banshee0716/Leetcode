from typing import List

class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort()  # 升序排序
        nums_sum = sum(nums)  # 初始化邊長總和
        n = len(nums)
        
        for i in range(n - 1, 1, -1):
            nums_sum -= nums[i]  # 更新邊長總和
            if nums_sum > nums[i]:  # 檢查是否可以形成多邊形
                return nums_sum + nums[i]  # 返回周長
        
        return -1  # 無法形成多邊形


    
    """
給定一個長度為 n 的正整數 nums 陣列。

多邊形是至少有 3 條邊的封閉平面圖形。多邊形的最長邊小於其其他邊的總和。

相反，如果有 k (k >= 3) 個正實數 a1, a2, a3, ..., ak，其中 a1 <= a2 <= a3 <= ... <= ak 和 a1 + a2 + a3 + 。 .. + ak-1 > ak，則總存在一個k 邊的多邊形，其長度為a1, a2, a3, ..., ak。

多邊形的周長是其邊長之和。

返回其邊可以由 nums 形成的多邊形的最大可能週長，如果無法創建多邊形，則返回 -1。

解題思路
1. 排序：
    -首先將數組nums進行升序排序。這樣可以保證我們在遍歷數組時，總是從最大的邊開始考慮。

2. 遍歷並檢查：
    -從數組的最後一個元素（即最大的邊）開始向前遍歷，對於每個當前邊nums[i]，檢查其是否可以與前面的邊形成多邊形。
    -按照多邊形的性質，一個邊的長度必須小於其他邊長之和。因此，我們只需要檢查前i-1個邊的和是否大於當前邊nums[i]。

3. 計算和更新：
    -在遍歷過程中，使用一個變量_sum來記錄當前所有邊的和，每次移動到下一個邊時，更新_sum減去當前邊的長度。
    -如果找到了一組邊可以構成多邊形，立即返回這組邊的周長（_sum + nums[i]）。
    -如果遍歷完畢沒有找到符合條件的邊，返回-1。
    
時間複雜度
    -對nums進行排序的時間複雜度為O(nlogn)，其中n是數組nums的長度。
    -遍歷排序後的數組來找到最大周長的時間複雜度為O(n)。
    -因此，總的時間複雜度為O(nlogn)。

空間複雜度
    -除了輸入和幾個變量外，沒有使用額外的空間，所以空間複雜度為O(1)。
    """