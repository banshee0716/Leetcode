class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 初始化 dp 陣列，因為我們只關心當前行和上一行，所以只需要兩行
        dp = [[1] * n for i in range(2)]

        # 從第 1 行和第 1 列開始遍歷
        for i in range(1, m):
            for j in range(1, n):
                # 到達 (i, j) 的不同路徑數量是到達 (i-1, j) 和 (i, j-1) 的路徑數量之和
                # 使用 i&1 來達到行交換的效果，節省空間
                dp[i & 1][j] = dp[(i - 1) & 1][j] + dp[i & 1][j - 1]

        # 返回到達 (m-1, n-1) 的不同路徑數量
        return dp[(m - 1) & 1][-1]

    
"""
解題思路
1. 創建一個二維陣列 dp，其中 dp[i][j] 代表到達 i, j 位置的不同路徑數量。
2. 對於邊界條件（即第一行和第一列），只有一條路徑可以到達，所以初始化為1。
3. 對於其餘的位置，到達該位置的路徑數量是到達其左側位置和上側位置的路徑數量之和。

時間複雜度: 我們遍歷了 m x n 的網格一次，所以時間複雜度是 O(m*n)。

空間複雜度: 因為我們只用了兩行來存儲 dp 值，所以空間複雜度是 O(n)。
"""