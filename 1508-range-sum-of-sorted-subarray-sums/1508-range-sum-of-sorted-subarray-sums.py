class Solution:
    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:
        h = [(x, i) for i, x in enumerate(nums)] #min-heap 
        print(h)
        heapify(h)
        
        ans = 0
        for k in range(1, right+1): #1-indexed
            x, i = heappop(h)
            if k >= left:
                ans += x
                
            if i+1 < len(nums):
                heappush(h, (x + nums[i+1], i+1))
            
        return ans % 1_000_000_007
    
    """
這個解決方案的靈感來自@milu 在這篇文章中的絕妙想法。版權歸原作者所有。

這個想法是在大小為 n 的優先權隊列中並行追蹤從 nums[i] (i=0...n-1) 開始的範圍總和。一開始，佇列使用 (nums[i], i) 進行初始化，即僅起始元素及其位置。在接下來的每個步驟中，將最小的 x, i 從佇列中彈出，並執行以下操作：

檢查步驟是否已到達左側，將 x 加到 ans 中；
透過新增 nums[i+1] 來擴展範圍總和 x（目前以 i 結束），同時將結束索引更新為 i+1。
經過正確的步驟後，ans 將是返回的正確答案。

 主要步驟：

我們重複以下步驟 right 次：

從堆中取出最小的數字。
如果這是第 left 到第 right 個數字，我們就把它加到答案中。
如果這個數字不是原數組的最後一個，我們就把它和下一個數字的和放回堆中。



c. 最後：

我們將答案除以 1,000,000,007 的餘數返回（這是為了處理可能的大數問題）。


為什麼這樣做有效：

這個方法可以幫我們找出所有可能的子數組和，而且是按照從小到大的順序。
我們不需要真的計算出所有的和，而是一邊計算一邊找出我們需要的那些和。


舉例說明：
假設我們有數組 [1, 2, 3]，我們想找出所有子數組的和：

開始時，堆中有：(1,0), (2,1), (3,2)
第一次取出 1，放入 (1+2,1)
第二次取出 2，放入 (2+3,2)
第三次取出 3
第四次取出 3 (1+2)
第五次取出 5 (2+3)
第六次取出 6 (1+2+3)

這樣我們就得到了所有子數組的和：1, 2, 3, 3, 5, 6，而且是按照從小到大的順序。
    """