class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:

        nums = sorted([num+(ord(ch)-79)//3*d            # Example : nums: [1,0,4,-5],  s:  'RLRL',  d:  2
                       for num, ch in zip(nums,s)])    
                                                        #  nums = sorted([1+2, 0-2, 4+2, -5-2])
                                                        #       = [-7,-2,3,6]

        return sum(map(mul, nums, range(1-len(nums),    #  sum(map(mul, [[-7,-2,3,6],[-3,-1,1,3]]))
                       len(nums), 2)))%1000000007       #  sum((-7*-3)+(-2*-1)+(3*1)+(6*3))
                                                        #  return 44
        #相遇不會改變彼此狀態
        
        
        
"""
有些機器人站在無限數軸上，其初始坐標由 0 索引的整數數組 nums 給出，一旦給出移動命令，它們就會開始移動。機器人每秒移動一個單位距離。

您將得到一個字符串 s ，表示機器人按照命令移動的方向。 “L”表示機器人將向數軸的左側或負側移動，而“R”表示機器人將向數軸的右側或正側移動。

如果兩個機器人發生碰撞，它們將開始向相反的方向移動。

返回命令後 d 秒後所有機器人對之間的距離總和。由於總和可能非常大，因此返回模 109 + 7。

筆記：

對於索引 i 和 j 處的兩個機器人，對 (i,j) 和對 (j,i) 被視為同一對。
當機器人發生碰撞時，它們會立即改變方向，不浪費任何時間。
當兩個機器人同時共享同一個地方時，就會發生碰撞。
例如，如果一個機器人位於向右的 0 位置，另一個機器人位於向左的 2 位置，則下一秒它們將同時處於 1 位置，並且它們將改變方向，下一秒第一個機器人將處於 1 位置。 0，向左行駛，另一個將在 2，向右行駛。
例如，如果一個機器人位於向右的 0 位置，另一個機器人位於向左的 1 位置，那麼下一秒，第一個機器人將位於 0 位置，向左行駛，另一個機器人將位於 1 位置，向右行駛。
"""
"""
該問題可以重寫為：“每個機器人分別根據其對應的元素是否在 LorR 中向左或向右移動。根據這些最終位置求出距離的總和。”

function(ord(ch)-79)//3 * dmaps'L'-->-d 和 'R'-->d

好奇且具有代數能力的讀者可以證明為什麼在示例中 [-7,-2,3,6] 和 [-3,-1,1,3] 的內積給出了正確答案。

當兩個機器人在某個時刻相遇時，
他們改變方向並再次繼續前進。
但你可以假設它們不會改變方向並繼續移動（因為它們花費 0 單位時間）。

讓他們行走，然後問題就變成求數組所有對 (i , j) 之間的差值之和：
"""