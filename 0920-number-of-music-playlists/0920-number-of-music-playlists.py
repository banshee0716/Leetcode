class Solution:
    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:
        mod = 10**9 + 7  # 用於取模，防止數字過大

        # 初始化 dp 矩陣
        dp = [[0 for _ in range(n + 1)] for _ in range(goal + 1)]
        dp[0][0] = 1  # 初始條件

        # 遍歷每一首歌和每一種可能的不同歌曲數量
        for i in range(1, goal + 1):
            for j in range(1, min(i, n) + 1):

                # 如果當前的歌曲是新的歌曲，則有 (n - j + 1) 種選擇。
                # 所以，我們可以在 dp[i-1][j-1] 的基礎上增加這些選擇。
                # 無論如何，我們都將播放新歌，所以不同的歌曲數量會加1 (j-1 -> j)。
                dp[i][j] = dp[i-1][j-1] * (n - j + 1) % mod

                # 如果這首歌曲是已經播放過的，但不在最近的k首歌中，
                # 則有 j 種選擇（因為我們有 j 首不同的歌曲），但要減去最近播放的 k 首歌，
                # 所以是 j - k 種選擇。
                # 我們的不同歌曲數量保持不變 (j -> j)。
                if j > k:
                    dp[i][j] = (dp[i][j] + dp[i-1][j] * (j-k)) % mod

        return dp[goal][n]  # 返回最終結果

        
"""
1. 定義二維dp矩陣，其中 dp[i][j] 表示在播放i首歌中有j首不同的歌曲的列表數量。
2. 初始化 dp[0][0] = 1，表示在播放0首歌並且沒有不同的歌曲的情況下只有一種可能性。
3. 遍歷每一首歌和每一種可能的不同歌曲數量。
4. 每首新的歌曲都有兩種情況：它是一首新的歌曲或它是已經播放過的歌曲（但不在最近的k首歌中）。

時間複雜度:
這個方法的時間複雜度是 O(goal * n)。

空間複雜度:
這個方法的空間複雜度也是 O(goal * n)，因為需要一個二維dp矩陣來存儲結果。
"""